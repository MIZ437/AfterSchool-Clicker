# CSV-Based Individual Audio Volume Management
# Implementation Guide and Documentation Examples

## 概要 (Overview)
このドキュメントは、CSVファイルを使用して個別音源の音量を管理するシステムの実装方法を説明します。
グローバル音量設定と個別音源音量設定を組み合わせることで、柔軟な音響制御を実現します。

## 技術的課題と解決策 (Technical Challenges and Solutions)

### 主な課題
1. **非同期処理の連鎖**: DataManager → AudioManager → 音声再生の順序制御
2. **キャッシュ問題**: DataManagerが古いCSVデータを使い続ける
3. **初期化タイミング**: CSVデータの利用可能タイミングが不明確
4. **デバッグの困難さ**: 音声再生失敗の原因が多層にわたる

### 解決アプローチ
1. **強制リロード機能**: キャッシュを無視してCSVから直接読み込み
2. **非同期待機**: DataManager完全ロード後にAudioManager初期化
3. **フォールバック機能**: CSV読み込み失敗時のハードコーディング音源
4. **詳細ログ**: 各段階での状態を可視化

## システム構成 (System Architecture)

### ファイル構造
```
assets/
├── data/
│   └── audio.csv          # 音声設定ファイル
├── se/                    # 効果音ファイル
│   ├── click.mp3
│   ├── purchase.mp3
│   └── fanfare.mp3
└── bgm/                   # BGMファイル
    └── title_theme.mp3

src/js/
├── dataManager.js         # CSV読み込み管理
├── audioManager.js        # 音声再生管理
└── main.js               # システム統合
```

### audio.csv フォーマット
```csv
id,filename,category,loop,volume,scene,description
click_sound,se/click.mp3,se,false,0.8,game,クリック効果音
purchase_sound,se/purchase.mp3,se,false,0.3,game,購入効果音
stage_unlock_sound,se/fanfare.mp3,se,false,0.1,game,ステージ解放音
title_bgm,bgm/title_theme.mp3,bgm,true,0.7,title,タイトル画面BGM
```

### 音量計算式
```
最終音量 = グローバル音量 × 個別音量
例: seVolume(0.8) × csvVolume(0.3) = 0.24
```

## 実装手順 (Implementation Steps)

### 1. DataManager拡張
```javascript
// 強制リロード機能
async reload() {
    this.loaded = false;
    this.loadPromise = null;
    this.data = { audio: null, ... };
    return await this._loadAllDataForced();
}

// キャッシュ無視読み込み
async _loadAllDataForced() {
    // CSVから直接読み込み、キャッシュを無視
}
```

### 2. AudioManager修正
```javascript
// 個別音量取得
getIndividualVolume(audioId) {
    const audioData = window.dataManager.getAudio();
    const audioItem = audioData.find(item => item.id === audioId);
    return audioItem ? parseFloat(audioItem.volume) : 1.0;
}

// 音声再生時の音量計算
async playSE(id) {
    const individualVolume = this.getIndividualVolume(id);
    audioClone.volume = this.seVolume * individualVolume;
}
```

### 3. 初期化順序制御
```javascript
// AudioManagerでDataManager待機
if (!window.dataManager.isLoaded()) {
    await window.dataManager.loadAll();
}

// データが空の場合は強制リロード
if (!audioData || audioData.length === 0) {
    await window.dataManager.reload();
}
```

## plan.md 記載例

```markdown
# Project Plan

## Phase 3: Audio System Enhancement

### 3.1 CSV Audio Configuration Setup
**Timeline**: 1-2 days
**Priority**: High

#### Tasks:
- [ ] Design audio.csv schema with required columns
  - id: unique identifier for each audio source
  - filename: relative path from assets/ directory
  - category: se/bgm classification
  - loop: boolean for background music
  - volume: individual volume multiplier (0.0-1.0)
  - scene: application context
  - description: human-readable description

- [ ] Create sample audio.csv with test data
- [ ] Implement CSV validation in DataManager
- [ ] Add cache invalidation mechanism for audio data updates

### 3.2 AudioManager Volume System Overhaul
**Timeline**: 2-3 days
**Priority**: High
**Dependencies**: 3.1 must be completed

#### Tasks:
- [ ] Implement `getIndividualVolume(audioId)` method
  - Parse CSV data from DataManager
  - Return individual volume multiplier
  - Handle missing/invalid data gracefully

- [ ] Modify `playSE()` method for volume calculation
  - Formula: `finalVolume = globalVolume × individualVolume`
  - Ensure compatibility with existing code
  - Maintain fallback for non-CSV audio sources

- [ ] Add async dependency management
  - Wait for DataManager.isLoaded() before proceeding
  - Implement retry mechanism for CSV loading failures
  - Create timeout handling for slow CSV loads

### 3.3 Cache Management & Data Integrity
**Timeline**: 1-2 days
**Priority**: Medium
**Dependencies**: 3.1, 3.2

#### Tasks:
- [ ] Implement forced CSV reload mechanism
  - Bypass DataManager cache when needed
  - Clear corrupted/stale data automatically
  - Add manual refresh capability for development

- [ ] Create data validation pipeline
  - Verify CSV structure on load
  - Check audio file existence
  - Log missing/invalid entries

- [ ] Add comprehensive error handling
  - Graceful degradation when CSV fails
  - Fallback to hardcoded audio sources
  - User-friendly error messages

### 3.4 Testing & Integration
**Timeline**: 1-2 days
**Priority**: High
**Dependencies**: 3.1, 3.2, 3.3

#### Tasks:
- [ ] Create test scenarios for volume differences
  - Test extreme values (0.01 vs 1.0)
  - Verify gradual volume changes
  - Test multiple simultaneous audio sources

- [ ] Integration testing with existing systems
  - Ensure compatibility with save/load system
  - Test scene transitions with audio
  - Verify settings menu integration

- [ ] Performance testing
  - Measure CSV loading impact
  - Test with large audio datasets
  - Optimize for mobile/low-end devices

### 3.5 Debug & Monitoring Tools
**Timeline**: 1 day
**Priority**: Medium
**Dependencies**: All above

#### Tasks:
- [ ] Implement comprehensive debug logging
  - CSV loading status and timing
  - Volume calculation details
  - Audio file loading success/failure
  - DataManager cache state

- [ ] Create developer tools for audio testing
  - Volume adjustment interface
  - Real-time CSV reload capability
  - Audio source inspection panel

#### Success Criteria:
- [ ] Individual audio volumes controllable via CSV
- [ ] No performance impact on game loading
- [ ] Fallback system works when CSV unavailable
- [ ] Debug logs provide clear troubleshooting info
- [ ] System works reliably across different browsers/devices

#### Risk Mitigation:
- **Risk**: CSV loading failures breaking audio system
  **Mitigation**: Robust fallback to hardcoded audio sources

- **Risk**: Performance impact from CSV parsing
  **Mitigation**: Implement caching and lazy loading

- **Risk**: Complex debugging of audio issues
  **Mitigation**: Comprehensive logging at each system layer
```

## design.md 記載例

```markdown
# Technical Design Document

## Audio System Architecture

### Overview
The audio system implements a two-tier volume control mechanism combining global volume settings with individual audio source volume multipliers defined in CSV configuration files.

### CSV-Based Audio Management

#### Data Schema
```csv
Column      | Type    | Range     | Required | Description
id          | string  | -         | Yes      | Unique identifier for audio source
filename    | string  | -         | Yes      | Relative path from assets/ directory
category    | string  | se|bgm    | Yes      | Audio type classification
loop        | boolean | true|false| Yes      | Whether audio should loop
volume      | float   | 0.0-1.0   | Yes      | Individual volume multiplier
scene       | string  | -         | Yes      | Application context/scene
description | string  | -         | No       | Human-readable description
```

#### Sample Configuration
```csv
id,filename,category,loop,volume,scene,description
click_sound,se/click.mp3,se,false,0.8,game,Standard UI click
purchase_sound,se/purchase.mp3,se,false,0.3,game,Item purchase confirmation
boss_music,bgm/boss_theme.mp3,bgm,true,0.6,game,Boss battle background music
```

### Volume Control Logic

#### Calculation Formula
```
Final Volume = Global Volume × Individual Volume × Context Modifier

Where:
- Global Volume: User-controlled master volume (0.0-1.0)
- Individual Volume: CSV-defined per-source volume (0.0-1.0)
- Context Modifier: Optional scene-based adjustment (0.0-1.0)
```

#### Implementation Flow
```
1. User triggers audio event (e.g., button click)
   ↓
2. AudioManager.playSE(audioId) called
   ↓
3. Check if sounds are loaded
   ↓
4. If not loaded: await loadSoundsSync()
   ↓
5. loadSoundsSync() ensures DataManager is ready
   ↓
6. If CSV data empty: force reload from source
   ↓
7. Retrieve individual volume from CSV data
   ↓
8. Calculate: finalVolume = globalVolume × csvVolume
   ↓
9. Create audio instance with calculated volume
   ↓
10. Play audio with proper volume level
```

### System Components

#### DataManager Responsibilities
- **CSV Loading**: Parse audio.csv on application startup
- **Caching**: Store parsed data for performance
- **Cache Management**: Invalidate when CSV updates detected
- **Error Handling**: Provide fallback data when CSV unavailable
- **Data Validation**: Ensure CSV structure integrity

##### Key Methods
```javascript
getAudio()                    // Return all audio configurations
getAudioById(id)             // Get specific audio configuration
reload()                     // Force refresh from CSV source
isLoaded()                   // Check if data is available
```

#### AudioManager Responsibilities
- **Volume Calculation**: Combine global and individual volumes
- **Audio Loading**: Create Audio objects from CSV definitions
- **Playback Control**: Manage audio instance lifecycle
- **Fallback Handling**: Use hardcoded sources when CSV fails
- **Performance**: Optimize for simultaneous audio playback

##### Key Methods
```javascript
playSE(audioId)              // Play sound effect with calculated volume
playBGM(audioId)             // Play background music with calculated volume
getIndividualVolume(audioId)  // Retrieve CSV-defined volume
loadSoundsSync()             // Ensure audio sources are loaded
```

### Critical Requirements

#### Dependency Management
1. **DataManager must be fully loaded before AudioManager accesses CSV data**
2. **AudioManager must wait for DataManager.isLoaded() = true**
3. **Fallback mechanism required if DataManager fails**

#### Cache Strategy
```javascript
// Cache invalidation triggers:
- Application startup
- CSV file modification detected
- Manual refresh requested
- Data corruption detected

// Cache bypass scenarios:
- Development mode active
- CSV loading previously failed
- Audio data array is empty
- Forced reload requested
```

#### Error Handling Strategy
```javascript
// Fallback hierarchy:
1. CSV-based audio loading (primary)
2. Hardcoded essential sounds (secondary)
3. Programmatic beep generation (tertiary)
4. Silent failure with logging (last resort)
```

#### Performance Considerations
- **Lazy Loading**: Only load audio files when needed
- **Preloading**: Cache frequently used sounds
- **Memory Management**: Dispose unused audio instances
- **Concurrent Loading**: Load multiple audio files in parallel

#### Debug & Monitoring
```javascript
// Required logging points:
- CSV loading start/completion/failure
- Individual volume calculations
- Audio file loading success/failure
- Cache invalidation events
- Fallback mechanism activation
- Performance timing measurements
```

### Integration Points

#### Save System Integration
- Audio volume preferences stored in user settings
- CSV modifications trigger cache refresh
- Settings UI reflects current volume calculations

#### Scene Management Integration
- Scene transitions may require audio context changes
- Background music switching based on scene
- Audio cleanup on scene transitions

#### UI Integration
- Volume sliders affect global volume multipliers
- Audio test buttons for immediate feedback
- Debug panel shows current audio system state

### Testing Requirements

#### Unit Testing
- Volume calculation accuracy
- CSV parsing edge cases
- Cache invalidation triggers
- Fallback mechanism activation

#### Integration Testing
- DataManager → AudioManager → Audio playback flow
- Save/load system compatibility
- Scene transition audio behavior
- Settings UI synchronization

#### Performance Testing
- CSV loading time measurement
- Memory usage with large audio datasets
- Concurrent audio playback stress testing
- Mobile device compatibility verification

### Security Considerations
- CSV file integrity validation
- Audio file path sanitization
- Prevent arbitrary file access via CSV manipulation
- Resource usage limits for audio files

### Future Extensibility
- Support for additional audio formats
- Dynamic volume automation/effects
- Audio compression/quality settings
- Spatial audio positioning
- Real-time audio mixing capabilities
```

## 使用方法 (Usage Instructions)

### 1. 新規プロジェクトでの実装
1. 上記のplan.mdとdesign.mdの内容をプロジェクトドキュメントに追加
2. audio.csvファイルを作成し、必要な音声ファイルを定義
3. DataManager、AudioManagerの実装を段階的に進行
4. テストケースを作成して動作確認

### 2. 既存プロジェクトへの追加
1. 現在の音声システムを分析
2. DataManagerの有無を確認（ない場合は作成）
3. AudioManagerを段階的に拡張
4. フォールバック機能で既存動作を保持

### 3. デバッグ時の確認ポイント
- DataManager.isLoaded()の状態
- CSV読み込み完了の確認
- 個別音量の計算結果
- 音声ファイルの読み込み状況

このガイドを参考に、他のプロジェクトでも効率的にCSV音声管理システムを実装できます。